---
description: "TDD — Test-Driven Development (deterministic first). Tests before or with any logic change, especially primary user actions and UI invariants."
required: false
category: "methodology"
subcategory: "tdd"
globs:
  - "src/**"
  - "app/**"
  - "domain/**"
  - "services/**"
  - "frontend/**"
  - "public/**"
  - "tests/**"
---

[SOURCE OF TRUTH]
- Editable source: `rules/42-tdd.mdc`
- Generated/consumed copy: `.cursor/rules/42-tdd.mdc` (keep references intact)

[INTENT]
- Define Test-Driven Development cycle and expectations.

[APPLICABILITY]
- Applies to TDD practice where adopted; guidance binding unless an explicit risk override per `.cursor/rules/3G-risk-overrides.mdc` is provided.

[TDD — TEST-DRIVEN DEVELOPMENT (DETERMINISTIC FIRST)]

[CORE MANDATE]
- Any change to behavior must be accompanied by tests that prove it. For critical flows and primary user actions (save, submit, delete, login, checkout, navigation), untested logic and unproven state invariants are rejected by default.

[PRINCIPLES]
- Determinism:
  - Tests must be deterministic, hermetic, and fast: no real network, real clock, random global state, or shared mutable fixtures.
  - Isolate external dependencies (HTTP, DB, filesystem, DOM, timers, randomness) behind interfaces or injected collaborators.
- Design for testability:
  - Structure code so core logic is pure or nearly pure and easy to call from tests.
  - Keep I/O, framework glue, and DOM wiring at the edges; keep domain/application logic in testable modules.
- Behavior over implementation:
  - Tests assert on observable behavior and contracts, not internal structure or incidental details.
  - Prefer CQS-friendly designs: queries are side-effect free and easy to assert; commands change state and are validated via observable outcomes.
- Coverage with intent:
  - Focus tests on invariants, edge cases, and failure modes, not just happy paths.
  - For primary actions, ensure at least one test covers:
    - “Action is enabled only when valid”, and
    - “Action is disabled when invalid”.

[STATE & INVARIANTS]
- Treat invariants as first-class citizens. Examples:
  - “Save button is disabled if and only if the form is invalid.”
  - “Modal is open if and only if overlay is visible and focus is trapped inside it.”
- Invariants must:
  - Be encoded explicitly in code (as predicates or small helper functions), and
  - Be exercised by tests or a harness, not just described in comments or documentation.
- For derived UI state (e.g., `isFormValid`, `validationState`, `isButtonDisabled`):
  - Prefer deriving from current inputs/validators in a single function rather than manually toggling flags in multiple places.
  - Initial state must be consistent with invariants (e.g., required fields start invalid; primary action starts disabled).
  - Event handlers must update invariants via the central function, not ad-hoc logic that can drift.

[FRONTEND & UI-SPECIFIC EXPECTATIONS]
- Primary UI controls (buttons/links) triggering important actions (save, delete, submit, login, payment, navigation) must not rely on “looks correct” reasoning alone.
- For client-side logic that controls these actions:
  - Provide at least one executable check: unit test, component test, end-to-end test, or a small scripted harness that asserts the invariants (e.g., enabling/disabling rules, error handling).
  - For forms:
    - Encode the validation and “is form valid?” logic in a separable function or module.
    - Ensure tests/harnesses cover at least:
      - Initial state (empty form → invalid; primary action disabled).
      - Valid minimal input → valid; primary action enabled.
      - Representative invalid states (e.g., missing required fields, mismatched passwords).
  - Avoid hiding logic inside opaque event handlers that are hard to exercise from tests; keep validation and state transitions in functions that do not depend on the DOM.
- For single-file demos (HTML + inline JS) that include primary actions:
  - Embed a small, opt-in Aegis demo harness (guarded by a flag such as `window.__AEGIS_DEMO_TESTS__`) that:
    - Does not run by default in normal usage.
    - Asserts the key invariants (initial invalid state, enabled state when valid, disabled state when invalid).
    - Produces clear console output on failures.
  - This harness is a stopgap and must be replaced by proper tests in production applications.

[WORKFLOW]
1. Before or alongside any logic change, write or update a test (or demo harness check) that captures the desired behavior or bug fix.
2. Implement the minimal code necessary to make the check pass.
3. Refactor implementation and tests to improve design while preserving coverage and invariants.
4. For UI-heavy code:
   - Extract validation and state logic into plain functions/modules.
   - Test those functions directly, and keep DOM glue thin.
5. Periodically perform small “safe breaks” (manual mutation) or use mutation testing tools (where available) to confirm tests actually catch regressions.

[REJECTION CRITERIA]
- Production or shared code changes that:
  - Introduce or modify logic without any corresponding test changes or clear evidence of existing coverage.
  - Add new primary user actions (buttons, forms, flows) without at least one executable check of their behavior and state invariants.
  - Depend on brittle conditions (timing hacks, global flags, DOM ordering) that are not encoded in tests.
- Deleting or weakening tests without:
  - A clear domain-level justification (acceptance criteria changed), and
  - Replacement tests that reflect the new behavior.

[VERIFICATION]
- For each PR/change:
  - Identify which test(s) or harness checks encode the changed behavior; if none exist, require creation of at least one.
  - For primary actions and critical flows, require:
    - Direct tests of enabling/disabling logic and error handling, or
    - A clearly documented plan to add tests before promoting beyond experimental/demo code.
  - Ensure tests satisfy docs/testing-standards.md (deterministic, meaningful, not relying on incidental details).
- For UI logic bugs found in manual testing (e.g., buttons never enabling or staying enabled when invalid), backfill tests or harness checks to capture them so they cannot regress silently.
