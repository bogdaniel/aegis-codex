---
description: "Architecture — Clean Architecture + Hexagonal ports/adapters + DDD + Context Map + Trust Tiers."
required: true
category: "topic"
subcategory: "architecture"
globs:
  - "src/**"
  - "app/**"
  - "backend/**"
  - "services/**"
  - "modules/**"
---

[ARCHITECTURE — CLEAN + HEXAGONAL + DDD + MODULAR CONTEXTS]

[CORE MANDATE]
- All non-trivial backend codebases must follow:
  - **Clean Architecture** layering,
  - **Hexagonal** port/adapter boundaries,
  - **Domain-Driven Design (DDD)** for modelling.
- The system is a **modular project** composed of **bounded contexts** with explicit trust tiers.

[MANDATORY WORKFLOW — CHECK RULES FIRST]
- **MANDATORY:** Before writing ANY code that touches architecture, you MUST:
  1. **Read `.cursor/rules/36-architecture.mdc`** - Understand layering, bounded contexts, trust tiers
  2. **Read `.cursor/rules/44-ddd.mdc`** - Understand DDD patterns, domain purity
  3. **Read relevant `50-lang-*.mdc`** - Understand language-specific requirements (path aliases, etc.)
  4. **Check existing code patterns** - If existing code violates rules, DO NOT copy it; fix it instead
  5. **Validate configuration** - Check `tsconfig.json`, ESLint config, etc. are correctly configured
- **MANDATORY:** Do NOT prioritize functionality over architecture. Architecture compliance is NON-NEGOTIABLE.
- **MANDATORY:** Do NOT copy existing violations. If you see code that violates architecture rules, that code is WRONG and must be fixed, not copied.
- **MANDATORY:** Architecture rules are checked FIRST, then code is written. There is no "get it working first, fix architecture later".
- **REJECTION CRITERIA:**
  - Code written without checking architecture rules first → **REJECT**
  - Code that copies existing architecture violations → **REJECT**
  - Code that prioritizes functionality over architecture → **REJECT**
  - Developer excuse "I prioritized functionality" or "I didn't check rules" → **REJECT**

[LAYERING — CLEAN ARCHITECTURE]
- **MANDATORY:** All non-trivial backend code MUST be organized into these four layers per bounded context:
  - **Domain**:
    - **MUST contain:** Entities, Value Objects, Domain Services, Domain Events, Repository interfaces (ports).
    - **MUST NOT contain:** Framework dependencies (Symfony/Laravel/HTTP/ORM), Infrastructure adapters, Interface adapters.
    - **MUST contain:** Business invariants and rules.
    - **MUST be:** Framework-free, ORM-free, HTTP-free.
  - **Application**:
    - **MUST contain:** Use cases, Commands/Queries, Application Services, Application ports.
    - **MUST depend on:** Domain layer (same context), ports/interfaces.
    - **MUST NOT depend on:** HTTP/DB frameworks directly, Infrastructure adapters, Interface adapters.
    - **MUST orchestrate:** Domain objects and ports only.
  - **Interface (Adapters-Inbound)**:
    - **MUST contain:** HTTP controllers, CLI commands, message consumers, BFFs.
    - **MUST translate:** External protocols (HTTP, CLI, messages) into Application calls.
    - **MUST delegate:** All business logic to Application use cases (controllers are thin).
    - **MUST NOT contain:** Business logic, validation rules, persistence logic.
  - **Infrastructure (Adapters-Outbound)**:
    - **MUST contain:** Persistence adapters, messaging adapters, external API clients, caching, filesystem.
    - **MUST implement:** Ports defined in Domain/Application layers.
    - **MUST contain:** ORM mappings, SDK usage, and technical glue.
    - **MUST NOT contain:** Business logic (move to Domain/Application).

[LAYERING RULES — EXPLICIT CONSTRAINTS]

**Domain Layer:**
- **MAY depend on:** Domain entities, value objects, domain services, domain events in same bounded context.
- **MUST NOT depend on:** Frameworks (HTTP, ORM, UI), infrastructure, interface/adapters, other bounded contexts' domain/infrastructure.
- **Verification:** Reference dep graph tool (Deptrac, ESLint import rules) or clear explanation of layer boundaries.

**Application Layer:**
- **MAY depend on:** Domain layer (same context), ports/interfaces, DTOs/commands/queries.
- **MAY depend on:** Other bounded contexts only via their application ports / published events.
- **MUST NOT depend on:** Other contexts' domain/infrastructure, shared DB tables, raw external DTOs.
- **Verification:** Reference dep graph tool or clear explanation of layer boundaries.

**Interface/Infrastructure Layers:**
- **MAY depend on:** Application + domain (same context).
- **MUST NOT depend on:** Other contexts' infra directly; must go through ACL or explicit contracts.
- **Verification:** Reference dep graph tool or clear explanation of layer boundaries.

[LAYERING RULES — DEPENDENCIES]
- **MANDATORY:** Dependency directions MUST follow these rules:
  - **Domain → (no inward dependencies):**
    - Domain MUST NOT depend on any other layer.
    - Domain MUST NOT import from Application, Interface, or Infrastructure.
    - Domain MAY import from other contexts' public API modules (rare, via Application layer).
  - **Application → Domain:**
    - Application MUST depend on Domain (same context).
    - Application MUST NOT depend on Interface or Infrastructure.
    - Application MAY depend on other contexts' Application public API modules.
  - **Interface → Application (+ Domain DTOs where strictly needed):**
    - Interface MUST depend on Application (same context).
    - Interface MAY depend on Domain DTOs (same context) for request/response mapping.
    - Interface MUST NOT depend on Infrastructure adapters directly (use ports).
  - **Infrastructure → Domain/Application:**
    - Infrastructure MUST depend on Domain/Application (same context).
    - Infrastructure MUST NOT depend on Interface layer.
- **FORBIDDEN:**
  - Domain depending on Interface/Infrastructure or frameworks → **REJECT**, use ports/adapters.
  - Application depending on Symfony/Laravel/ORM/HTTP clients directly → **REJECT**, use ports/adapters.
  - Cross-layer shortcuts (controller → repository directly, skipping use cases) → **REJECT**, use Application use cases.
  - Domain importing from `@context/infra/*` or `@context/interface/*` → **REJECT**, Domain cannot import Infrastructure/Interface.
- Layer-specific import patterns:
  - **Domain Layer:**
    - Can import: Other Domain entities/VOs within same context, public API modules from other contexts (rare).
    - Cannot import: Application, Infrastructure, Interface layers.
  - **Application Layer:**
    - Can import: Domain (same context), Ports (same context), public API modules (other contexts).
    - Cannot import: Infrastructure, Interface layers.
  - **Interface Layer:**
    - Can import: Application (same context), Domain DTOs (same context), public API modules (other contexts).
    - Cannot import: Infrastructure adapters directly (use ports).
  - **Infrastructure Layer:**
    - Can import: Domain, Application (same context), public API modules (other contexts).
    - Cannot import: Interface layer.
- Import restrictions (enforced via path aliases):
  - Domain layer MUST NOT import from Infrastructure or Interface aliases (e.g., `@context/infra/*`, `@context/interface/*`).
  - Domain can only import from its own domain layer or other contexts' public API modules (if needed).
  - Example: `@identity/domain/Entities/User.ts` cannot import from `@identity/infra/*` or `@identity/interface/*`.

[PORTS & ADAPTERS — HEXAGONAL ARCHITECTURE]
- Ports (interfaces) are defined in Domain/Application layers; adapters implement them in Infrastructure/Interface.
- Port ownership:
  - Each port MUST be owned by exactly one bounded context (the context that defines its contract).
  - The owning context defines the canonical port interface (e.g., `IdentityContext/Application/Ports/IdentityPort.ts`).
  - Port names reflect the owning context's domain language.
- Cross-context port usage (ACL pattern):
  - When a context needs to use another context's port, it MUST define its own ACL interface with a distinct name.
  - The ACL interface shields the consuming context from the provider's exact semantics.
  - Example: `IdentityContext` owns `IdentityPort`; `OrdersContext` defines `IdentityValidationPort` (ACL) that adapts to `IdentityPort`.
  - Forbidden: Multiple contexts defining ports with the same name but different contracts (e.g., both `IdentityContext` and `OrdersContext` having `IdentityPort`).
  - ACL adapter in Infrastructure layer translates between the ACL interface and the canonical port.

[BOUNDED CONTEXTS — MANDATORY]
- **MANDATORY:** All backend code MUST be organized into bounded contexts.
- **MANDATORY:** Architect MUST identify bounded contexts and assign each a trust tier (H/M/S) before implementation.
- **MANDATORY:** Context map + trust tiers MUST be documented for non-trivial systems (3+ contexts or any Tier H context).
- There is no "shared" or "common" code outside of bounded contexts (except infrastructure utilities).
- **Exception:** Small, clearly-marked Tier S utilities (one-off scripts, migrations) may live outside bounded contexts, but MUST NOT grow into core services.
- **Explicitly FORBID:**
  - Shared mutable DB across contexts without contracts → **REJECT**, use explicit contracts (APIs, events).
  - Direct cross-context domain/entity sharing → **REJECT**, use public API modules.
  - Bounded context without assigned trust tier → **REJECT**, assign tier (H/M/S) first.
- Each major business area is a **bounded context** with its own:
  - Ubiquitous language,
  - Entities/Aggregates,
  - Value Objects,
  - Domain Events.
- Within a bounded context:
  - Favor rich domain models over anemic data structures.
  - Use aggregates to enforce invariants; avoid leaking internal state.
- Cross-context interactions:
  - Must go through explicit contracts (APIs, messages).
  - Never share persistence models across bounded contexts.

[DDD — BOUNDED CONTEXTS & MODELLING]
- **MANDATORY:** All backend code MUST be organized into bounded contexts.
- **REJECTION CRITERIA:**
  - Code organized by technical layers only (e.g., `models/`, `services/`, `controllers/`) without bounded contexts → **REJECT**.
  - "Shared" domain models used across multiple business areas → **REJECT**, create bounded contexts.
  - Missing bounded context structure → **REJECT**, organize into contexts first.
  - Scripts/migrations accumulating real business logic → **REJECT**, promote into proper bounded context.
- Port ownership in cross-context communication:
  - The owning context defines the canonical port (e.g., `IdentityContext` owns `IdentityPort`).
  - Consuming contexts MUST define their own ACL interface with a distinct name (e.g., `OrdersContext` defines `IdentityValidationPort`, not `IdentityPort`).
  - This prevents confusion from duplicate port names with different contracts.
  - ACL adapters in Infrastructure layer translate between ACL interfaces and canonical ports.
- Public API modules (facades):
  - Each bounded context MUST define a small "public API" module per layer that's the only approved entry point for other contexts.
  - Structure: `ContextName/Application/index.ts` (or `public.ts`) exports only approved use cases and ports.
  - Cross-context imports MUST go through these public API modules, not direct imports into internal subfolders.
  - Example: `import { RegisterUser, IdentityPort } from '@identity/app'` (via `IdentityContext/Application/index.ts`), NOT `import { RegisterUser } from '@identity/app/UseCases/RegisterUser/RegisterUser.js'`.
  - Anti-pattern: Allowing direct imports into arbitrary subfolders (e.g., `@identity/app/UseCases/RegisterUser/RegisterUser.js`) from other contexts.
- Public API module structure:
  - **MUST export:** Use cases (classes), Ports (interfaces for cross-context use).
  - **SHOULD export:** Command/Query types (as types only, using `export type`).
  - **MUST NOT export:** Internal implementations, Infrastructure adapters, Domain entities directly.
  - **Versioning:** Breaking changes to public APIs require deprecation period; use semantic versioning for public API modules.
- Public API module structure:
  - **MUST export:** Use cases (classes), Ports (interfaces for cross-context use).
  - **SHOULD export:** Command/Query types (as types only, using `export type`).
  - **MUST NOT export:** Internal implementations, Infrastructure adapters, Domain entities directly.
  - **Versioning:** Breaking changes to public APIs require deprecation period; use semantic versioning for public API modules.
- Cross-context import restrictions:
  - A context MAY NOT import another context's Domain or Infrastructure directly.
  - Cross-context imports MUST go through documented public API modules only (e.g., `@identity/app`, `@identity/domain` if domain has public API).
  - Forbidden: `import { User } from '@identity/domain/Entities/User.js'` from OrdersContext (must use `@identity/app` public API if needed).
  - Forbidden: `import { InMemoryUserRepository } from '@identity/infra/Adapters/InMemoryUserRepository.js'` from any other context.
  - Only public API modules (facades) are approved entry points for cross-context access.

[CONTEXT MAP & TRUST TIERS (H/M/S)]
- **MANDATORY:** Every bounded context MUST be assigned a trust tier before implementation.
- Architect MUST identify bounded contexts and assign each a risk tier (S/M/H) as per 00-persona RISK TIERS.
- **REJECTION CRITERIA:**
  - Bounded context without assigned trust tier → **REJECT**, assign tier (H/M/S) first.
  - Tier H contexts with heavy framework dependencies → **REJECT**, use ports/adapters.
  - Tier S contexts directly accessing Tier H persistence → **REJECT**, use APIs/messages.
- Every bounded context must be assigned:
  - A **trust tier**:
    - Tier H (High / Safety Kernel): Auth, Policy, Ledger, Risk, Compliance.
    - Tier M (Medium / Business Core).
    - Tier S (Surface / Edge / UI/BFF).
  - Documented relationships in a **context map** (who can call whom, sync vs async).
- Tier rules:
  - Tier H:
    - **MUST:** Minimize moving parts.
    - **MUST:** Avoid unnecessary services.
    - **MUST:** Have stricter observability & security baselines (tie to 30-security.mdc / 32-observability.mdc).
    - Minimal dependencies; strong isolation.
    - Strict Clean/Hex; no "shortcut" access to DBs or external services.
    - Higher test coverage, property-based tests for invariants where applicable.
  - Tier M:
    - Clean/Hex/DDD applied pragmatically.
    - May integrate with more external services, but still through ports/adapters.
  - Tier S:
    - Mainly orchestration and presentation.
    - No direct access to Tier H persistence; must call Tier H via APIs/messages.

[CONTEXT STRUCTURE REQUIREMENT]
- **MANDATORY:** For non-trivial backends, code MUST be organized into bounded contexts (e.g. IdentityContext, OrdersContext).
- **MANDATORY:** Each bounded context MUST have exactly four sublayers:
  - `ContextName/Domain/` - Entities, Value Objects, Domain Services, Domain Events, Repository interfaces
  - `ContextName/Application/` - Use cases, Commands/Queries, Application Services, Application ports
  - `ContextName/Infrastructure/` - Persistence adapters, external API clients, messaging adapters
  - `ContextName/Interface/` - HTTP controllers, CLI commands, message consumers
- **FORBIDDEN:**
  - Code organized by technical layers only (e.g., `models/`, `services/`, `controllers/`) without bounded contexts → **REJECT**, organize into contexts first.
  - Bounded context missing any of the four required sublayers → **REJECT**, add missing layers.
  - Shared code outside bounded contexts (except Tier S utilities) → **REJECT**, create bounded contexts.
- **Verification:** Require reference to dep graph tool (Deptrac, ESLint import rules) or clear explanation of layer boundaries.

[MODULAR PROJECT STRUCTURE]
- **MANDATORY:** The project MUST be modular:
  - **MUST:** Group code into context modules, e.g.:
    - `src/AuthContext/Domain`, `src/AuthContext/Application`, `src/AuthContext/Infrastructure`, `src/AuthContext/Interface`.
    - `src/BillingContext/...`, `src/CasinoCoreContext/...`, etc.
  - **MUST:** Each context module MUST have the four required sublayers (Domain, Application, Infrastructure, Interface).
  - **MUST NOT:** Have "misc/shared" dumping grounds that bypass contexts.
- **MANDATORY:** New features:
  - **MUST:** Belong to an existing bounded context or trigger creation of a new one.
  - **MUST NOT:** Be added to "shared" or "common" modules outside bounded contexts (except Tier S utilities).
  - **MUST:** Follow the four-layer structure (Domain, Application, Infrastructure, Interface) within their context.

[UTILITIES & SCRIPTS]
- Migrations and one-off scripts are **Tier S utilities** with limited scope.
- They may live outside bounded contexts (e.g., `migrations/`, `scripts/`).
- **REJECTION CRITERIA:**
  - If a script starts accumulating real business logic → **REJECT**, promote it into a proper bounded context.
  - Scripts accessing Domain/Application directly without going through ports → **REJECT**, use proper architecture.
- **Naming:** Use clear prefixes (e.g., `migrate_`, `script_`) to mark them as Tier S utilities.

[OBSERVABILITY & NON-FUNCTIONALS]
- Each bounded context exposes:
  - **Request metrics** (latency, error rates).
  - **Domain metrics** (e.g., number of payouts, fraud flags, logins).
  - **Logs with correlation IDs** and principal information (without sensitive data).
  - **Traces** with spans around use case boundaries.
- Use case boundaries:
  - Must log start/end with correlation ID + principal (user/tenant/service).
  - Logs must not contain secrets, credentials, or sensitive PII beyond what is strictly necessary.

[SECURITY & TRUST]
- mTLS between contexts where possible; avoid plain HTTP inside the core network.
- AuthN vs AuthZ:
  - AuthN (Identity, tokens) handled by an **AuthContext**.
  - AuthZ (permissions, policies) handled by a **PolicyContext** or equivalent.
- Principle of least privilege:
  - DB, queue, and service-account permissions are scoped to per-context needs.
  - No “root” credentials embedded in general-purpose services.

[SLOs & ERROR BUDGETS]
- Tier H and Tier M contexts must have:
  - Explicit latency and availability SLOs.
  - Error budgets that shape design decisions:
    - Tier H favors simplicity, fewer moving parts, and minimal dependencies.
    - Tier S can accept more complexity for UX, but not at the expense of Tier H/M reliability.

[ENFORCEMENT & TOOLING]
- Static analysis tooling:
  - **TypeScript/JavaScript:**
    - ESLint plugin: `eslint-plugin-import` with custom rules to enforce path aliases and prevent relative imports.
    - Custom ESLint rule: Enforce path aliases, prevent relative imports beyond one level.
    - TypeScript compiler: Use `paths` in `tsconfig.json` (already required).
    - Consider: `dependency-cruiser` for dependency graph validation and architecture enforcement.
  - **PHP:**
    - `Deptrac` for layer/context dependency enforcement.
    - `PHPStan` level 8+ for strict type checking and architecture validation.
  - **General:**
    - Pre-commit hooks: Run static analysis before commits to catch violations early.
    - CI gates: Fail builds on architecture violations (layer dependencies, cross-context imports, path alias violations).
- Use Deptrac/static analysis to:
  - Enforce layer dependency rules.
  - Prevent Domain from importing frameworks.
  - Prevent Domain from importing Infrastructure or Interface layers (e.g., `@context/infra/*`, `@context/interface/*`).
  - Prevent cross-context imports that bypass public API modules (facades).
  - Enforce that cross-context imports only use public API entry points (e.g., `@context/app`, not `@context/app/UseCases/...`).
  - Prevent cross-context direct imports to Domain or Infrastructure (e.g., `@other-context/domain/*`, `@other-context/infra/*`).
  - Verify that all cross-context imports go through public API modules only.
- Use contract tests and schema validation for:
  - Cross-context APIs (OpenAPI/JSON Schema, Protobuf).
  - Event schemas (see anti-corruption/events rules).

[WIRING & BOOTSTRAP FILES]
- Wiring files (dependency injection containers, bootstrap files):
  - Located at root or `infra/wiring/` directory (outside bounded contexts).
  - Can import from multiple contexts (they're outside contexts).
  - MUST use public API modules for cross-context imports.
  - Can import Infrastructure adapters directly (for wiring only).
  - Should be the ONLY place that imports Infrastructure adapters across contexts.
- Naming: Use `*-wiring.ts`, `*-bootstrap.ts`, or `*-container.ts` suffix.
- Example: `app-wiring.ts`, `dependency-container.ts`, `bootstrap.ts`.

[REJECTION CRITERIA]
- **FORBIDDEN:** Business logic in controllers → **REJECT**, move to Application use cases.
  - See `examples/refactoring/clean-architecture/fat-controller/` for before/after example.
- **FORBIDDEN:** Framework dependencies in Domain/Application → **REJECT**, use ports/adapters pattern.
  - See `examples/refactoring/clean-architecture/framework-in-domain/` for before/after example.
- **FORBIDDEN:** Direct cross-context Domain/Infrastructure imports → **REJECT**, use public API modules.
  - See `examples/refactoring/clean-architecture/cross-context-direct/` for before/after example.
- **FORBIDDEN:** Controllers accessing repositories/ORM directly → **REJECT**, use Application use cases.
- **FORBIDDEN:** Business logic in Infrastructure → **REJECT**, move to Domain/Application.
- **FORBIDDEN:** Anemic domain models with logic in services → **REJECT**, use rich domain models.
- Code that places business logic directly in controllers, OR in Infrastructure, bypassing Domain/Application.
- Direct use of external DTOs/entities inside Domain without mapping/ACL.
- Cross-context database access or entity reuse.
- Tier H services that depend heavily on frameworks or bypass ports/adapters.

**See also:**
- `.cursor/rules/45-solid-principles.mdc` — SOLID principles (SRP, DIP violations related to architecture)
- `.cursor/rules/3A-anti-patterns.mdc` — Anti-patterns catalog (architecture anti-patterns)
- `.cursor/rules/38-anti-corruption-events.mdc` — Anti-corruption layers and event schemas
- `examples/refactoring/clean-architecture/` — Before/after examples for architecture violations
- `test/example-app/` — Canonical TypeScript Clean Architecture + DDD demo (IdentityContext, OrdersContext)
- `tests/policies/` — Policy scenarios validating architecture enforcement (see `tests/policies/README.md`)

[DOCUMENTATION REQUIREMENTS]
- Public API documentation:
  - **MANDATORY:** Public API modules that are imported by other bounded contexts MUST have a JSDoc/TSDoc (or equivalent) header that documents purpose, stability, and breaking-change policy.
  - **SHOULD:** Modules used only inside a single bounded context SHOULD be documented, but lack of a header should not be an immediate REJECT.
  - Documentation should include:
    - Purpose of the module.
    - List of all exports with brief descriptions.
    - Breaking changes and deprecations (if any).
  - **REJECTION CRITERIA:**
    - Cross-context public API module without documentation → **REJECT**, add documentation first.
    - Public API module exporting internal implementations → **REJECT**, export only approved contracts.
- Context map documentation:
  - MUST document all cross-context dependencies.
  - MUST document trust tiers for each context.
  - MUST document communication patterns (sync vs async).
