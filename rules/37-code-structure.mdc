---
description: "Code structure and organization standards."
required: true
category: "topic"
subcategory: "code-structure"
globs:
  - "src/**"
  - "app/**"
  - "domain/**"
  - "services/**"
  - "tests/**"
---

[SOURCE OF TRUTH]
- Editable source: `rules/37-code-structure.mdc`
- Generated/consumed copy: `.cursor/rules/37-code-structure.mdc` (keep references intact)

[INTENT]
- Define code structure and organization standards (modularity, imports, testability).

[APPLICABILITY]
- Applies to all code organization across contexts; must align with architecture/DDD rules unless an explicit risk override per `.cursor/rules/3G-risk-overrides.mdc` exists.

[CROSS-REFERENCES]
- See `.cursor/rules/36-architecture.mdc` and `.cursor/rules/31-testing.mdc` for binding architecture/testing mandates applied alongside this file.
- Risk overrides follow `.cursor/rules/3G-risk-overrides.mdc`.

[CODE STRUCTURE BASELINE]
- Modularity & feature slices: organize code into cohesive modules and feature-oriented verticals (e.g., feature/domain → application/service → infrastructure → interface); avoid grab-bag "utils" files; keep boundaries inside features clear and explicit. Align with docs/architecture/design-principles.md and docs/architecture/architecture-patterns.md.
- Naming & layout: use clear, descriptive, domain-aligned names; avoid ambiguous abbreviations; keep directory depth reasonable; prefer explicit, stable public entry points (barrel/index/public files) over fragile deep relative imports; avoid circular dependencies. For TypeScript projects: use path aliases instead of relative imports for maintainability and clarity. For Clean Architecture/DDD: structure as `@context/layer/*` to make architecture boundaries explicit. For bounded contexts: define public API modules (facades) per context layer (e.g., `ContextName/Application/index.ts`) as the only approved entry point for cross-context imports.

[IMPORT & MODULE RULES — EXPLICIT]
- **FORBID:** Deep relative imports that cross contexts/layers (e.g. ../../../SomeOtherContext).
- **REQUIRE:**
  - Clear top-level module/folder boundaries for features/contexts.
  - No circular dependencies between modules.
  - Feature slices / modules map cleanly to:
    - Domain concepts.
    - Bounded contexts where applicable.
- Code-level heuristics: apply DRY/KISS/YAGNI with judgment (prefer a bit of duplication over the wrong abstraction); keep functions small and focused (~20–30 lines where practical); isolate I/O and side effects from pure logic; follow Tell, Don’t Ask and Law of Demeter; make behavior explicit rather than relying on hidden magic. See docs/architecture/design-principles.md.
- Testability & observability: structure code so that core logic is easy to unit test (dependency injection, seams for I/O, time, randomness); keep cross-cutting concerns like logging/metrics/tracing in dedicated modules or middleware instead of scattered calls in business logic. Coordinate with docs/testing-standards.md and docs/observability-standards.md.
- Config & environment: externalize environment/configuration; never hardcode secrets or environment-specific constants; remove dead code and unused dependencies regularly as part of normal maintenance.

[VERIFICATION]
- Run the formatter and linter for the language to ensure structure/naming/import hygiene, and reference any architecture/import-rule checks (if present) that enforce modular boundaries.

**See also:**
- `.cursor/rules/36-architecture.mdc` — Clean Architecture, Hexagonal Architecture, DDD patterns (BINDING)
- `.cursor/rules/44-ddd.mdc` — Domain-Driven Design methodology (BINDING)
- `.cursor/rules/45-solid-principles.mdc` — SOLID principles integrated with architecture
- `test/example-app/` — Canonical TypeScript Clean Architecture + DDD demo (path aliases, bounded contexts)
- `examples/refactoring/clean-architecture/` — Before/after examples for structure violations
- `docs/architecture/design-principles.md` — Foundational design principles
