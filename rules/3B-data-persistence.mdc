---
description: "Data & persistence standards: schema design, migrations, multi-tenancy, data ownership."
required: true
category: "topic"
subcategory: "data"
globs:
  - "src/**"
  - "app/**"
  - "domain/**"
  - "infrastructure/**"
  - "migrations/**"
---

[DATA & PERSISTENCE BASELINE]

### [RELATIONAL SCHEMA DESIGN]

#### Primary Keys & Foreign Keys
- **MANDATORY:** Every table MUST have both:
  - **Integer primary key:** Auto-increment integer (`id` or `{table}_id`) used for internal references, joins, and performance optimization.
  - **UUID:** Universally unique identifier (`uuid` or `public_id`) used for external/public-facing identifiers, API responses, and distributed systems.
- **MANDATORY:** Integer primary key MUST be:
  - Auto-incrementing (database-generated).
  - Used for internal foreign key relationships (performance, index efficiency).
  - NOT exposed in public APIs or external interfaces.
- **MANDATORY:** UUID MUST be:
  - Indexed (unique index) for lookup performance.
  - Used in public APIs and external interfaces (prevents enumeration, improves security).
  - Used for cross-system references and distributed scenarios.
- **MANDATORY:** Foreign keys MUST be explicitly defined with referential integrity constraints (ON DELETE/UPDATE behavior documented).
- **MANDATORY:** Foreign key relationships MUST:
  - Use integer primary keys for internal relationships (performance).
  - Use UUIDs only when crossing system boundaries or for external references.
  - Align with bounded context ownership (see Data Ownership section).
- **Verification:** Check that all tables have both integer PK and UUID; foreign keys are defined with explicit constraints; UUIDs are indexed.

#### Indexing Strategy
- **MUST:** Create indexes on frequently queried columns (WHERE, JOIN, ORDER BY clauses).
- **MUST:** Use composite indexes for multi-column queries (order matters; follow query patterns).
- **MUST NOT:** Over-index (slows writes; use selectively based on query patterns).
- **MANDATORY:** Tier H/M contexts MUST document index strategy and query patterns.
- **Verification:** Review query plans (EXPLAIN/EXPLAIN ANALYZE); identify missing indexes on hot paths.

#### Normalization vs Denormalization
- **Default:** Prefer normalized schemas (3NF minimum) unless performance/consistency requirements justify denormalization.
- **MANDATORY:** Denormalization MUST be:
  - Documented with justification (performance target, consistency requirements).
  - Reviewed and approved for Tier H/M contexts.
  - Tested for correctness and performance impact.
- **MUST NOT:** Denormalize without explicit justification and documentation.
- **Verification:** Check that denormalized tables have documented justification; review denormalization decisions in code reviews.

#### Soft Deletes vs Hard Deletes vs Archival
- **MANDATORY:** Choose deletion strategy per bounded context:
  - **Soft deletes:** Use `deleted_at` timestamp for audit/compliance requirements (Tier H contexts).
  - **Hard deletes:** Acceptable for Tier S contexts with no compliance requirements.
  - **Archival:** Move to separate archive tables/partitions for long-term retention (Tier H/M contexts).
- **MANDATORY:** Soft delete strategy MUST be consistent within a bounded context (all tables use same pattern).
- **MANDATORY:** Queries MUST filter soft-deleted records by default (explicit `WHERE deleted_at IS NULL` or equivalent).
- **Verification:** Check that deletion strategy is documented per context; queries filter soft-deleted records.

#### Audit Trails
- **MANDATORY:** Tier H/M contexts MUST have audit trails:
  - **Created/Updated timestamps:** `created_at`, `updated_at` (UTC, monotonic clocks).
  - **Created/Updated by:** `created_by`, `updated_by` (user/service identity).
  - **Audit tables/logs:** Separate audit tables for sensitive operations (Tier H contexts).
- **MANDATORY:** Audit logs MUST be immutable (append-only; no updates/deletes).
- **MANDATORY:** Audit logs MUST include correlation IDs for traceability.
- **Verification:** Check that Tier H/M contexts have audit trails; audit logs are immutable.

### [MIGRATIONS]

#### Forward-Only vs Reversible Strategy
- **MANDATORY:** Choose migration strategy per bounded context:
  - **Forward-only:** Preferred for Tier H contexts (simpler, fewer failure modes).
  - **Reversible:** Acceptable for Tier M/S contexts with low-risk changes.
- **MANDATORY:** Reversible migrations MUST be tested (up + down) before deployment.
- **MANDATORY:** Breaking schema changes (column renames, type changes) MUST use multi-step migrations (add new column → migrate data → remove old column).
- **Verification:** Check that migration strategy is documented; reversible migrations are tested.

#### Zero-Downtime Migrations
- **MANDATORY:** Tier H/M contexts MUST use zero-downtime migration strategies:
  - **Additive changes:** Add columns/tables (nullable, with defaults if needed).
  - **Backfill data:** Migrate existing data in background jobs.
  - **Remove old columns:** After backfill complete and code deployed.
- **MANDATORY:** Zero-downtime migrations MUST be:
  - Documented with rollback plan.
  - Tested in staging environment.
  - Monitored during deployment (error rates, latency).
- **MUST NOT:** Deploy migrations that lock tables or cause downtime without explicit approval.
- **Verification:** Check that Tier H/M contexts have zero-downtime migration plans; migrations are tested in staging.

#### Rollback Strategy
- **MANDATORY:** Every migration MUST have a documented rollback plan:
  - **Forward-only:** Rollback via new migration (revert schema change).
  - **Reversible:** Rollback via `down` migration.
- **MANDATORY:** Rollback plans MUST be tested before deployment.
- **MANDATORY:** No "auto-migrations" without review (all migrations must be code-reviewed).
- **Verification:** Check that migrations have rollback plans; migrations are code-reviewed.

### [MULTI-TENANCY]

#### Allowed Patterns
- **MANDATORY:** Choose multi-tenancy pattern per bounded context:
  - **Schema-per-tenant:** Isolated schemas per tenant (Tier H contexts; strict isolation).
  - **Row-based tenancy:** Single schema with `tenant_id` column (Tier M/S contexts; shared infrastructure).
- **MANDATORY:** Row-based tenancy MUST use strict tenant filters:
  - **MUST:** All queries MUST include `tenant_id` filter (enforced at repository/ORM level).
  - **MUST NOT:** Allow queries without tenant filter (fail closed).
  - **MUST:** Use database row-level security (RLS) where supported (PostgreSQL, SQL Server).
- **Verification:** Check that multi-tenancy pattern is documented; row-based queries include tenant filters.

#### Cross-Tenant Query Prevention
- **MANDATORY:** Cross-tenant queries MUST be:
  - Explicitly prohibited by default (fail closed).
  - Allowed only with explicit ACL + justification (admin operations, compliance audits).
  - Logged and audited (Tier H contexts).
- **MANDATORY:** Cross-tenant queries MUST require:
  - Explicit authorization check (admin role, compliance role).
  - Audit log entry (who, what, when, why).
  - Approval workflow for Tier H contexts.
- **Verification:** Check that cross-tenant queries are prohibited by default; allowed queries are logged and audited.

### [DATA OWNERSHIP]

#### Bounded Context Ownership
- **MANDATORY:** Each bounded context MUST own its data:
  - **MUST:** Each context has its own database schema/tables.
  - **MUST NOT:** Share database tables across contexts without explicit, versioned contracts.
  - **MUST:** Document data ownership in context map (see `36-architecture.mdc`).
- **MANDATORY:** Domain models MUST reflect owned data:
  - **MUST:** Domain entities map to owned tables (no shared entities).
  - **MUST NOT:** Use "shared God tables" across contexts (create separate tables per context).
- **MANDATORY:** Cross-context data access MUST go through:
  - **APIs:** REST/GraphQL endpoints (preferred).
  - **Events:** Domain events with schemas (see `38-anti-corruption-events.mdc`).
  - **MUST NOT:** Direct database access across contexts.
- **Verification:** Check that contexts own their data; cross-context access uses APIs/events.

#### Context Map Integration
- **MANDATORY:** Data ownership MUST be documented in context map:
  - **MUST:** List owned tables/schemas per context.
  - **MUST:** Document cross-context data dependencies (APIs, events).
  - **MUST:** Document data contracts (schemas, versions).
- **Verification:** Check that context map documents data ownership; cross-context dependencies are explicit.

### [INTEGRATION WITH ARCHITECTURE & DDD]

#### Architecture Rules
- **MANDATORY:** Data persistence MUST align with `.cursor/rules/36-architecture.mdc`:
  - **MUST:** Infrastructure layer implements persistence adapters (repositories).
  - **MUST:** Domain layer defines repository interfaces (ports).
  - **MUST NOT:** Domain layer depends on ORM/framework types (use ports/adapters).
- **MANDATORY:** Data ownership MUST align with bounded contexts:
  - **MUST:** Each context owns its data (no shared tables).
  - **MUST:** Cross-context access uses APIs/events (no direct DB access).
- **Verification:** Check that persistence follows Clean Architecture; data ownership aligns with bounded contexts.

#### DDD Rules
- **MANDATORY:** Data persistence MUST align with `.cursor/rules/44-ddd.mdc`:
  - **MUST:** Domain entities reflect owned data (no shared entities).
  - **MUST:** Aggregates enforce data consistency boundaries.
  - **MUST:** Value objects map to owned columns (no shared value objects).
- **Verification:** Check that domain models reflect owned data; aggregates enforce consistency.

### [VERIFICATION]

- **Schema design:** Check that all tables have primary keys; foreign keys are defined; indexes are documented.
- **Migrations:** Check that Tier H/M contexts have zero-downtime migration plans; migrations are tested.
- **Multi-tenancy:** Check that tenant filters are enforced; cross-tenant queries are prohibited by default.
- **Data ownership:** Check that contexts own their data; cross-context access uses APIs/events.
- **Context map:** Check that data ownership is documented in context map.

**See also:**
- `.cursor/rules/36-architecture.mdc` — Architecture rules (bounded contexts, data ownership)
- `.cursor/rules/44-ddd.mdc` — DDD rules (domain models, aggregates)
- `.cursor/rules/38-anti-corruption-events.mdc` — Event schemas for cross-context communication
- `.cursor/rules/33-performance.mdc` — Performance standards (indexing, query optimization)
- `test/example-app/` — Canonical demo (data persistence in Clean Architecture)
