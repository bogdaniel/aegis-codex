---
description: "ATDD — Acceptance Test-Driven Development (done = proven). Define acceptance before implementation."
required: false
category: "methodology"
subcategory: "atdd"
globs:
  - "acceptance/**"
  - "src/**"
  - "app/**"
  - "tests/**"
---

[SOURCE OF TRUTH]
- Editable source: `rules/40-atdd.mdc`
- Generated/consumed copy: `.cursor/rules/40-atdd.mdc` (keep references intact)

[INTENT]
- Define Acceptance Test-Driven Development expectations (define acceptance before implementation).

[APPLICABILITY]
- Applies to acceptance-level specs/tests; guidance binding unless an explicit risk override per `.cursor/rules/3G-risk-overrides.mdc` is provided.

[ATDD — ACCEPTANCE TEST-DRIVEN DEVELOPMENT (DONE = PROVEN)]

[CORE MANDATE]
- Define acceptance criteria and key scenarios before designing the implementation; “done” is defined by observable outcomes, not code volume.

[PRINCIPLES]
- Express acceptance using domain language and clear outcomes that stakeholders understand; avoid technical jargon (DB tables, classes, HTTP internals).
- Align acceptance criteria with bounded contexts and domain concepts; reflect the ubiquitous language of the domain (DDD) when applicable.
- Turn critical acceptance criteria into executable tests (API/E2E/contract tests) that remain stable across refactors.
- Prioritize a small set of high-value acceptance tests over large, flaky, UI-heavy suites; use lower layers (unit/integration) to cover details.
- Keep acceptance tests focused on behavior and business rules; do not assert on incidental implementation details or layout.
- When behavior changes, update acceptance criteria first, then tests, then implementation.

[WORKFLOW]
1. Discover and refine acceptance criteria with stakeholders (optionally using BDD-style Given/When/Then examples).
2. Select key scenarios and implement them as executable acceptance tests.
3. Use TDD at lower levels (unit/integration) to drive design until acceptance tests pass.
4. Keep acceptance tests stable; when behavior changes, revise criteria and tests deliberately.

[ANTI-PATTERNS]
- Writing “acceptance” tests after implementation as documentation theater.
- Overly UI-coupled scenarios that break on cosmetic changes.
- Acceptance suites that are slow, flaky, and rarely run.
- Scenarios that mirror implementation steps instead of domain rules.

[VERIFICATION]
- For any new feature or major change, ensure:
  - Acceptance criteria are explicitly stated (story, ADR, or acceptance test names).
  - At least one executable acceptance test exists for critical behavior, or a clear justification is given if not feasible.
- Cross-check against docs/testing-standards.md to ensure acceptance tests are deterministic, meaningful, and part of the CI pipeline.
