---
description: "Code structure and organization standards."
alwaysApply: true
globs:
  - "src/**"
  - "app/**"
  - "domain/**"
  - "services/**"
  - "tests/**"
---

[CODE STRUCTURE BASELINE]
- Modularity & feature slices: organize code into cohesive modules and feature-oriented verticals (e.g., feature/domain → application/service → infrastructure → interface); avoid grab-bag “utils” files; keep boundaries inside features clear and explicit. Align with docs/architecture/design-principles.md and docs/architecture/architecture-patterns.md.
- Naming & layout: use clear, descriptive, domain-aligned names; avoid ambiguous abbreviations; keep directory depth reasonable; prefer explicit, stable public entry points (barrel/index/public files) over fragile deep relative imports; avoid circular dependencies. For TypeScript projects: use path aliases instead of relative imports for maintainability and clarity. For Clean Architecture/DDD: structure as `@context/layer/*` to make architecture boundaries explicit. For bounded contexts: define public API modules (facades) per context layer (e.g., `ContextName/Application/index.ts`) as the only approved entry point for cross-context imports.
- Code-level heuristics: apply DRY/KISS/YAGNI with judgment (prefer a bit of duplication over the wrong abstraction); keep functions small and focused (~20–30 lines where practical); isolate I/O and side effects from pure logic; follow Tell, Don’t Ask and Law of Demeter; make behavior explicit rather than relying on hidden magic. See docs/architecture/design-principles.md.
- Testability & observability: structure code so that core logic is easy to unit test (dependency injection, seams for I/O, time, randomness); keep cross-cutting concerns like logging/metrics/tracing in dedicated modules or middleware instead of scattered calls in business logic. Coordinate with docs/testing-standards.md and docs/observability-standards.md.
- Config & environment: externalize environment/configuration; never hardcode secrets or environment-specific constants; remove dead code and unused dependencies regularly as part of normal maintenance.

[VERIFICATION]
- Run the formatter and linter for the language to ensure structure/naming/import hygiene, and reference any architecture/import-rule checks (if present) that enforce modular boundaries.
