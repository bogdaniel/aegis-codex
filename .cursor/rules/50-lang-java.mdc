---
description: "Java standards: idiomatic, typed, and architecture-enforced."
alwaysApply: false
globs:
  - "**/*.java"
---

[JAVA STANDARDS]
- Stack: Java 17+ (LTS), Maven/Gradle.
- Style/lint: Google Java Style, Checkstyle, SpotBugs; command: `mvn checkstyle:check` or `./gradlew checkstyleMain`.
- Errors: use checked exceptions appropriately; prefer `Optional` over null returns; no raw types.
- Concurrency: `CompletableFuture`, `ExecutorService` with bounded pools; avoid `synchronized` blocks where possible; use `java.util.concurrent` primitives.
- Safety: parameterized queries (JPA/Hibernate); validate inputs; avoid logging secrets; TLS for network calls; run `mvn dependency-check:check` or `./gradlew dependencyCheckAnalyze`.
- Testing: JUnit 5, Mockito, TestContainers; `mvn test` or `./gradlew test`; table-driven tests including negatives.
- Performance: avoid unnecessary object creation; reuse pooled connections; prefer streams for transformations; use `@Cacheable` judiciously.
- Verification artifact: `mvn clean verify` or `./gradlew check && ./gradlew test && ./gradlew dependencyCheckAnalyze`.

[ARCHITECTURE INTEGRATION — CLEAN + HEX + DDD]

- **MANDATORY:** All Java backend code MUST follow Clean Architecture, Hexagonal Architecture, and DDD patterns as defined in `.cursor/rules/36-architecture.mdc`.

- Module/Project Structure:
  - Require clear module/project boundaries (Maven/Gradle multi-module or equivalent) and consistent package namespaces per bounded context.
  - Example: `com.company.identitycontext.domain`, `com.company.identitycontext.application`, `com.company.orderscontext.domain`.
  - Each bounded context should be a separate Maven module or Gradle subproject.
  - Package structure: `{base}.{context}.{layer}.{feature}` (e.g., `com.company.identity.domain.user`).

- Domain layer (`{context}.domain` package):
  - **FORBIDDEN:** No framework dependencies whatsoever.
  - **FORBIDDEN:** `@Entity`, `@Table`, `@Repository`, `@Service`, `@Component`, `@Autowired`, `@RequestMapping`, `@RestController`, `@SpringBootApplication`, or any Spring/Jakarta EE annotation.
  - **FORBIDDEN:** Spring Data JPA repositories, Hibernate annotations, or ORM frameworks in Domain.
  - **FORBIDDEN:** `HttpServletRequest`, `HttpServletResponse`, or any servlet/Jakarta EE types.
  - Contains:
    - Entities (plain Java classes), Value Objects, Domain Services, Domain Events, Repository interfaces (plain interfaces).
  - All business invariants live here.
  - Example: `com.company.identity.domain.User` (plain POJO), `com.company.identity.domain.UserRepository` (interface).

- Application layer (`{context}.application` package):
  - **FORBIDDEN:** Direct framework dependencies (same as Domain).
  - **FORBIDDEN:** Spring annotations (`@Service`, `@Component`, `@Autowired`, etc.).
  - **FORBIDDEN:** Spring Data repositories or JPA repositories.
  - Use Cases, Commands/Queries, Application Services.
  - Depends on Domain; can depend on simple DTOs and interfaces.
  - No direct ORM/HTTP/framework usage; use ports (interfaces) defined in Domain/Application.
  - Example: `com.company.identity.application.RegisterUser` (use case), `com.company.identity.application.commands.RegisterUserCommand` (DTO).

- **REJECTION CRITERIA:**
  - Domain/Application code importing Spring/Jakarta EE classes → **REJECT**, use ports/adapters.
  - Use case using `HttpServletRequest` or Spring `@Autowired` → **REJECT**, use dependency injection via constructor.
  - Domain entity annotated with `@Entity` or `@Table` → **REJECT**, use plain Java classes.
  - Application use case annotated with `@Service` → **REJECT**, use plain Java classes.

- Interface layer (`{context}.interface` package, HTTP/CLI adapters):
  - Controllers (`@RestController`), console commands, message consumers, view models.
  - Maps HTTP/CLI → Application use cases (input DTOs) and maps results → HTTP/JSON/View models.
  - **MANDATORY:** Controllers are thin; delegate to Application use cases.
  - **FORBIDDEN:** Business logic in controllers → **REJECT**, move to Application use cases.
  - Example: `com.company.identity.interface.http.IdentityController` (thin, delegates to `RegisterUser` use case).

- Infrastructure layer (`{context}.infrastructure` package):
  - JPA entities, Spring Data repositories, external API clients, message publishers.
  - Implements ports (interfaces) from Domain/Application.
  - Contains ORM mappings, SDK usage, and technical glue.
  - Example: `com.company.identity.infrastructure.persistence.JpaUserRepository` (implements `UserRepository` port).

- Forbidden patterns:
  - Business logic inside controllers, services annotated with `@Service`, or JPA entities.
  - Domain code depending on Spring annotations or framework-specific classes.
  - Cross-context DB access or using one bounded context's entities in another.
  - Controllers accessing repositories directly → **REJECT**, use Application use cases.

[SPRING BOOT INTEGRATION]

- Spring Boot is allowed in Infrastructure and Interface layers only.
- Use Spring Boot for:
  - Dependency injection (wiring Infrastructure adapters to Application use cases).
  - HTTP controllers (`@RestController` in Interface layer).
  - Database configuration (JPA, connection pooling in Infrastructure).
  - External service clients (REST templates, WebClient in Infrastructure).
- **Domain/Application remain pure:**
  - No Spring annotations in Domain/Application packages.
  - Use constructor injection in Application use cases (Spring wires dependencies, but use cases don't know about Spring).
  - Example: `RegisterUser` use case receives `UserRepository` via constructor (Spring provides implementation, but use case doesn't import Spring).

[LARAVEL CONVENTIONS]

- Follow Spring Boot conventions by default; diverge only with strong reasons.
- Controllers:
  - Keep thin; delegate to Application use cases.
  - Use dependency injection via constructor (Spring handles wiring).
  - Example:
    ```java
    @RestController
    @RequestMapping("/api/identity")
    public class IdentityController {
        private final RegisterUser registerUser;
        
        public IdentityController(RegisterUser registerUser) {
            this.registerUser = registerUser;
        }
        
        @PostMapping("/register")
        public ResponseEntity<Void> register(@RequestBody RegisterUserRequest request) {
            // Map HTTP → Command
            var command = new RegisterUserCommand(request.email(), request.password());
            // Delegate to use case
            registerUser.execute(command);
            return ResponseEntity.ok().build();
        }
    }
    ```
- Configuration:
  - Use `@Configuration` classes in Infrastructure layer for wiring.
  - Wire Application use cases with Infrastructure adapters.
  - Example:
    ```java
    @Configuration
    public class IdentityWiring {
        @Bean
        public UserRepository userRepository(JpaUserRepository jpaRepo) {
            return new JpaUserRepositoryAdapter(jpaRepo);
        }
        
        @Bean
        public RegisterUser registerUser(UserRepository repo) {
            return new RegisterUser(repo, new BCryptPasswordHasher());
        }
    }
    ```

[SECURITY & DATA SAFETY]

- Input handling:
  - Validate and sanitize all untrusted input; use Bean Validation (`@Valid`, `@NotNull`, etc.) in Interface layer.
  - Use Spring Security for authentication/authorization (in Interface/Infrastructure layers only).
- Persistence:
  - Use JPA/Hibernate with parameterized queries; never build SQL via string concatenation.
  - Avoid dynamic queries without parameter binding.
- Secrets & credentials:
  - Never hard-code secrets; use Spring `@Value` with environment variables or Spring Cloud Config.
- Authentication & authorization:
  - Keep AuthN/AuthZ logic in appropriate contexts (IdentityContext, PolicyContext).
  - Use Spring Security in Interface layer; Domain/Application remain framework-free.

[PERFORMANCE & SCALABILITY]

- Query behavior:
  - Avoid N+1 queries; use JPA `@EntityGraph` or `JOIN FETCH` where necessary.
  - Use pagination (`Pageable`) for large result sets.
- Caching:
  - Use Spring `@Cacheable` in Infrastructure layer only (not Domain/Application).
  - Invalidate cache explicitly on domain events or state changes.
- Connection pooling:
  - Configure HikariCP or equivalent in Infrastructure layer.

[TESTING & TOOLING]

- Testing:
  - Use JUnit 5 with:
    - Unit tests for Domain and Application (no Spring context).
    - Integration tests for Infrastructure and Interface boundaries (use `@SpringBootTest`).
  - Mock external services; avoid real network calls in tests.
  - Use TestContainers for database integration tests.
  - Ensure critical domain invariants are covered (happy path + edge cases + error paths).
- Static analysis & QA:
  - Run Checkstyle: `mvn checkstyle:check` or `./gradlew checkstyleMain`.
  - Run SpotBugs: `mvn spotbugs:check` or `./gradlew spotbugsMain`.
  - Run dependency check: `mvn dependency-check:check` or `./gradlew dependencyCheckAnalyze`.
- CI pipeline (baseline commands):
  - `mvn clean verify` or `./gradlew clean build`.
  - `mvn checkstyle:check` or `./gradlew checkstyleMain`.
  - `mvn spotbugs:check` or `./gradlew spotbugsMain`.
  - `mvn dependency-check:check` or `./gradlew dependencyCheckAnalyze`.
  - `mvn test` or `./gradlew test`.

[ANTI-PATTERNS]

- Anemic models used as dumb structs while controllers hold all logic.
- Direct use of Spring annotations in Domain/Application code (`@Service`, `@Component`, `@Autowired`).
- Large God classes/services that mix responsibilities across multiple bounded contexts.
- Inline SQL, hand-built JSON strings, or manual serialization where frameworks provide safe abstractions.
- Copy-pasting validation rules or business logic across controllers instead of centralizing in Domain/Application.
- Controllers accessing repositories directly (bypassing Application use cases).

[VERIFICATION]

- For Java changes:
  - Confirm Domain/Application packages have no Spring/Jakarta EE imports.
  - Check that domain code is framework-free and follows Clean/Hex/DDD layering.
  - Run the standard toolchain (Checkstyle, SpotBugs, dependency check, tests).
- For Spring Boot:
  - Cross-check structure against `.cursor/rules/36-architecture.mdc`.
  - Ensure controllers are thin and domain logic is in Domain/Application layers.
  - Verify Spring is only used in Infrastructure/Interface layers.
