---
description: "DDD — Domain-Driven Design (boundaries and invariants). Maintain domain purity and bounded contexts."
alwaysApply: true
globs:
  - "src/**"
  - "domain/**"
  - "application/**"
  - "infrastructure/**"
  - "docs/architecture/**"
  - "contracts/**"
  - "docs/adr/**"
---

[DDD — DOMAIN-DRIVEN DESIGN (BOUNDARIES & INVARIANTS)]

[CORE MANDATE]
- Model complex domains explicitly using ubiquitous language, bounded contexts, aggregates, and invariants; keep domain logic independent of technical concerns.

[PRINCIPLES]
- Ubiquitous language: use domain terms consistently in code (types, methods, modules) and documentation; avoid leaky technical names in the domain layer.
- Bounded contexts: partition the domain into cohesive contexts with clear boundaries and ownership; define explicit contracts (APIs, events, schemas) at context borders.
- Aggregates & invariants: design aggregates as consistency boundaries; enforce invariants inside them rather than in random services or controllers.
- Domain purity: keep domain model free from frameworks and infrastructure (no ORMs, HTTP, or persistence concerns in domain types); infrastructure depends on domain, not vice versa.
  - **Domain purity clauses MUST refer to 36-architecture.mdc for layer rules.**
- Context mapping: document relationships between contexts (partnerships, upstream/downstream, ACLs) and keep ADRs and diagrams up to date when boundaries or contracts change.
- Align with architecture patterns in docs/architecture/architecture-patterns.md and systemic guidance in docs/architecture/system-decomposition.md.

[DOMAIN PURITY — HARD CONSTRAINTS]
- Domain purity clauses MUST refer to 36-architecture.mdc for layer rules.
- **REQUIRE:**
  - Aggregate boundaries documented.
  - Ubiquitous language present in code (namespaces/packages, class names).
  - Context map (even lightweight) for non-trivial domains.
- **Add:** "If design is simple CRUD with no real domain complexity, keep DDD minimal and explain why – do not over-complicate."

[INVARIANT PROTECTION]
- Validate at aggregate boundaries; reject or correct invalid commands early.
- Make illegal states unrepresentable through type modeling and construction rules.
- Test invariants explicitly (unit and property-based tests where helpful).
- Document critical business rules directly in domain code (names, comments, and tests), not only in external docs.

[ANTI-PATTERNS]
- Anemic domain models (entities with just getters/setters and no behavior).
- God aggregates or services that know too much and own unrelated responsibilities.
- Technical concerns (ORM, HTTP, framework annotations) leaking into domain types.
- Bypassing invariants via direct setters, public mutable fields, or raw persistence access.
- Context boundaries ignored “for convenience” (shared DB tables, cross-context backdoor calls).

[VERIFICATION]
- For domain-heavy changes, ensure:
  - Types and modules reflect domain language and bounded contexts.
  - Invariants are enforced in aggregates/domain services and covered by tests.
  - Contracts between contexts (APIs, events, schemas) are explicit and versioned.
  - Architecture docs (context maps, ADRs) are updated when boundaries or invariants change.
