---
description: "PHP standards — modern, typed, Laravel-aligned, and architecture-safe."
alwaysApply: true
globs:
  - "src/**/*.php"
  - "app/**/*.php"
  - "modules/**/*.php"
  - "contexts/**/*.php"
  - "tests/**/*.php"
---

[PHP — SCOPE]

- Applies to all first-party PHP code (domain, application, controllers, console commands, jobs, tests).
- Excludes vendor/third-party packages.
- For Laravel projects, this rule is **in addition** to the detailed guidelines in:
  - `docs/laravel-php-ai-guidelines.md` (canonical Laravel/PHP style & conventions).

[LANGUAGE & VERSION]

- Version:
  - Target **PHP 8.2+** (or project-wide minimum if higher).
  - Use `declare(strict_types=1);` at the top of all non-legacy PHP files.
- Types:
  - Use native type declarations for parameters, return types, and properties.
  - Use short nullable notation (`?Type`) instead of `Type|null`.
  - Prefer typed properties over docblocks; use docblocks only for:
    - Generics (collections),
    - Array shapes,
    - Non-obvious semantics.

[STYLE, DOCBLOCKS & NAMING]

- Follow PSR-1/PSR-12 strictly; enforce via `phpcs`/`phpcbf`.
- Naming:
  - Classes: PascalCase (`UserService`, `OrderStatus`).
  - Methods/variables: camelCase (`getUserName`, `$firstName`).
  - Constants: SCREAMING_SNAKE_CASE.
- Docblocks:
  - No docblocks for fully type-hinted methods unless adding meaningful description.
  - When documenting iterables, use generics:
    - `/** @return Collection<int, User> */`
  - Use array shape notation for fixed keys.
  - Import classes used in docblocks; avoid fully-qualified names inside `@return`/`@param`.
- Control flow:
  - Prefer early returns; avoid deep nesting and unnecessary `else`.
  - Always use curly braces, even for single-line `if`/loops.
  - Ternaries only for simple cases; multi-line ternaries must remain readable.

[ARCHITECTURE INTEGRATION — CLEAN + HEX + DDD]

- Domain layer (`Domain/` in contexts/modules):
  - **FORBIDDEN:** No framework dependencies whatsoever.
  - **FORBIDDEN:** `Request`, `Response`, `Controller`, `Model`, `DB`, `Auth`, `Config`, `Cache`, `Queue`, `Mail`, `Log`, `Validator`, `Gate`, `Policy`, `Route`, `Schema`, `Migration`, or any Laravel/Symfony class.
  - **FORBIDDEN:** Laravel facades (`\Illuminate\Support\Facades\*`) or helper functions (`request()`, `auth()`, `config()`, etc.).
  - Contains:
    - Entities, Value Objects, Domain Services, Domain Events, Repository interfaces.
  - All business invariants live here.
- Application layer (`Application/`):
  - **FORBIDDEN:** Direct framework dependencies (same as Domain).
  - **FORBIDDEN:** Laravel facades or helper functions.
  - Use Cases, Commands/Queries, Application Services.
  - Depends on Domain; can depend on simple DTOs and interfaces.
  - No direct ORM/HTTP/framework usage; use ports defined in Domain/Application.
- **REJECTION CRITERIA:**
  - Domain/Application code importing Laravel/Symfony classes → **REJECT**, use ports/adapters.
  - Use case using `\Illuminate\Http\Request` or `request()` helper → **REJECT**, pass DTOs.
  - Domain entity extending `Illuminate\Database\Eloquent\Model` → **REJECT**, use plain PHP classes.
- Interface layer (`Interface/`, HTTP/CLI adapters):
  - Controllers, console commands, route handlers, view models.
  - Maps HTTP/CLI → Application use cases (input DTOs) and maps results → HTTP/JSON/View models.
- Infrastructure layer (`Infrastructure/`):
  - ORM entities, Eloquent models, repositories, queue handlers, mailers, external API clients.
  - Implements ports (interfaces) from Domain/Application.
- Forbidden patterns:
  - Business logic inside controllers, jobs, listeners, or Eloquent models.
  - Domain code depending on Laravel facades or framework-specific classes.
  - Cross-context DB access or using one bounded context’s models in another.

[LARAVEL CONVENTIONS]

- Follow Laravel’s documented conventions by default; diverge only with strong reasons.
- Routes:
  - URLs: kebab-case.
  - Route names: camelCase.
  - Controllers: plural resource controllers where applicable.
- Controllers:
  - Keep thin; delegate to Application use cases.
  - Use dependency injection; avoid resolving services via facades where reasonable.
- Validation:
  - Prefer Form Requests and array notation for multiple rules.
  - Custom validation rules in snake_case.
- Configuration:
  - Config file names kebab-case; keys snake_case.
  - Use `config()` helper; avoid `env()` outside config.
- See `docs/laravel-php-ai-guidelines.md` for detailed Laravel conventions, naming standards, and examples.

[SECURITY & DATA SAFETY]

- Input handling:
  - Validate and sanitize all untrusted input; never trust `Request` data directly.
  - Use Laravel’s validation, policies, gates, and authorization for access control.
- Persistence:
  - Use prepared statements/ORM; never build SQL via string concatenation.
  - Avoid dynamic queries without parameter binding.
- Output:
  - Escape data in views; use Blade’s escaping by default.
- Secrets & credentials:
  - Never hard-code secrets; use env variables/secret managers.
- Authentication & authorization:
  - Keep AuthN/AuthZ logic in appropriate contexts; no “role checks” scattered randomly.
  - Prefer policies/gates over ad-hoc `if ($user->role === 'admin')` logic.

[PERFORMANCE & SCALABILITY]

- Query behavior:
  - Avoid N+1 queries; use eager loading where necessary.
  - Use pagination/scrolling for large result sets.
- Caching:
  - Cache expensive computations and queries where appropriate (Redis/APCu).
  - Invalidate cache explicitly on domain events or state changes.
- PHP runtime:
  - Enable OPCache in production.
  - Avoid premature micro-optimizations; favor clarity unless profiling says otherwise.

[TESTING & TOOLING]

- Testing:
  - Use `phpunit` or Pest with:
    - Unit tests for Domain and Application.
    - Integration tests for Infrastructure and Interface boundaries.
  - Mock external services; avoid real network calls in tests.
  - Ensure critical domain invariants are covered (happy path + edge cases + error paths).
- Static analysis & QA:
  - Run `phpstan` (or Psalm) at a strict level (e.g. `--level=max`) for all first-party code.
  - Keep the baseline clean; do not suppress critical issues.
- CI pipeline (baseline commands):
  - `composer install` (or `composer install --no-dev` for prod images).
  - `phpcs --standard=PSR12` (or project standard).
  - `phpstan analyse` at strict level.
  - `composer audit`.
  - `./vendor/bin/phpunit` or `./vendor/bin/pest`.

[ANTI-PATTERNS]

- Anemic models used as dumb structs while controllers hold all logic.
- Direct use of global helpers/facades in Domain/Application code (`request()`, `config()`, `auth()`).
- Large God classes/services that mix responsibilities across multiple bounded contexts.
- Inline SQL, hand-built JSON strings, or manual serialization where the framework provides safe abstractions.
- Copy-pasting validation rules or business logic across controllers instead of centralizing in Domain/Application.

[VERIFICATION]

- For PHP changes:
  - Confirm files have `declare(strict_types=1);` and proper typing.
  - Check that domain code is framework-free and follows Clean/Hex/DDD layering.
  - Run the standard toolchain (phpcs, phpstan, tests).
- For Laravel:
  - Cross-check structure/naming against `docs/laravel-php-ai-guidelines.md`.
  - Ensure controllers are thin and domain logic is in Domain/Application layers.
